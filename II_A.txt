Chapter II:
My compositional practice with Python, Abjad, and Lilypond
		A: Methodology
        In the preceding chapter we have seen some of the strengths and potential weaknesses of Abjad and Lilypond when compared with similar software, as well as some potential logical pitfalls when working with these programs. In my recent compositional work, I have begun to amalgamate a workflow out of the ecosystem of Python, Abjad, and Lilypond, by learning from and embracing the idiosyncrasies of the software. The use of these tools in tandem is advantageous for my work due to the beautiful flexibility of Lilypond's notational algorithm and Abjad’s clarification of Lilypond’s model of music notation through Python’s Object-Oriented nature, as well as Python’s innumerable logical and mathematical abilities. Not only are Abjad and Lilypond both immensely rich in their features, but, due to their open source nature, their source code is accessible to the user for further modification. Occasionally I have found the need to tweak Abjad's source code in order for it to perform functions that I desire, but more often than this, the composer will find the need to build tools to simplify the process of engraving. In my work, I often desire a structural rigor, where rhythms, pitches, performance techniques, and instrumentation, among an infinite number of other parameters, are balanced together by a plan or logic that gives meaning, a possible rightness or wrongness, to potential musical realities. (This is something that composers often struggle very hard to achieve and should not be unfamiliar?) Very often, a rigorous structure falls apart when constructed by hand because humans are prone to err, while computers, on the other hand, don't make mistakes unless you tell them to, thus working with the Python programming language allows for a consistency in formal rigor that might be otherwise unattainable. (it also allows for the potential modeling of complex systems or algorithmic music) (Since Lilypond draws and has a looser{?} model of notation than other software, it allows the composer to have greater graphic freedom, but since it has no GUI it can spend more memory power when calculating collisions. Also since it allows you to include scheme functions, you are able to affect other features like proportional spacing across an entire score instead of manually dragging note heads like in finale or sibelius.) (Abjad seems tailor-made for polyphony (unlike OM or PWGL which seem to be hell-bent on single-voice-abstraction). It has no restrictions in this regard...and since you have direct access to the Python code {unlike in OM or PWGL} you can VERY EASILY use THE SAME MATERIAL across multiple instruments at different points in time.) (Python's object-oriented potential models musical thought more clearly than LISP) In this chapter we will take a look at the compositional advantages of working with these programs such as how to formalize(automate?) potentially tedious tasks, the benefits of an iterative compositional workflow, possibilities for composing with algorithms or models.  In the end, the greatest strength of this ecosystem is its flexibility.

			1.) how is this useful to me as a composer?

                BUT HOW has this become a useful workflow for me as a composer?

			2.) automating the boring stuff



			3.) composing in an iterable fashion



			4.) composing with algorithms and models



			5.) a comfortable formalism in score control is not necessarily algorithmic utopia

			This process should not be misperceived as a purely algorithmic system for music composition.
			Certainly, formalizing elements in a score
			
			6.) Music is for bodies, so it can be difficult at times to control the piece in such a way that it is not just performable, but idiomatic (what do I really mean by idiomatic?) [should this go in chapter 1?]